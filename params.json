{"name":"A Pragmatic Architect","tagline":"Architecture Posts","body":"# RESTful Interfaces in the Small and in the Large\r\n\r\n June, 17th 2015 \r\n\r\nThis post outlines an architecture strategy to design-in-the-small standardized components - just following the *Don't Repeat Yourself (DRY)* principle - and to scale them for whole application landscapes. \r\n\r\n##Introduction\r\n\r\n### Problem\r\nAt the beginning, we often implement a few interfaces. The number of interfaces grows then over time significantly. Interface implementations are often representing a significant percentage of the code base and hence costs.  \r\n\r\nWhat **architectures strategies** for implementing interfaces provide *economies of scale* and facilitate the transition from the *programming-in-the-small* to the *programming-in-the-large*? \r\n\r\n\r\n### Solution\r\n\r\nThe solution, which I present here, is based on the following principles\r\n\r\n-   Adopt early on *design patterns* to standardize the design;\r\n\r\n-   Use the programming-language's *interface* to decouple the pattern elements; and\r\n\r\n-   Generalize pattern elements to re-use them across the board. \r\n\r\nThis is nothing new per se. But, the interesting twist is how to start programming- in-the-small and evolve the design to one that fits for programming-in-the-large. This requirement rules out strategies requiring a large initial investment.\r\n\r\nAs a case study, I show how to apply these principles to the  implementation of RESTful interfaces in the programming language Clojure. Clojure offers offers an interface notion, called *protocols*, and a *macro* mechanism that facilitates the generalization and re-use. As a design pattern, we use the  *Model-View-Controller (MVC)* design pattern []. For a brief summary of concepts, see Appendix. \r\n\r\n##The Solution\r\nHere, I use a simplified example for explanatory purposes. In particular, the functional scope is limited and data storage, security features and so on are omitted. The evolutionary design is outlined by a series of mini-tutorials for this example, which are available on [here](https://github.com/glgit/tutorial/). \r\n\r\nAn Interface Component provides in our case just\r\n\r\n-  A set of RESTful interfaces with  their *resources* and *methods*.  For instance, a resource currency ``account `` providing a ``GET`` method that accepts an account identifier and returns , if the caller is authorized,  the account data in JSON. \r\n\r\n-  A mocked data set that the RESTful interfaces are delivering \r\n\r\n## Implementing a simple interface \r\n\r\n### Hello World Example\r\nIn Clojure, the library  [ring](https://github.com/ring-clojure/ring) and [compojure](https://github.com/weavejester/compojure)      enable to define interfaces and *end-points* in terms of *routes* and their run-time context.  \r\n\r\nAs an example, I use these libraries to implement an interface that delivers a static HTML page. This is our \"hello world\" example to get started.\r\n\r\n~~~Clojure\r\n(defn home\r\n  \"Function returning a static html page\"\r\n  [req]\r\n  (render (io/resource \"index.html\") req))\r\n\r\n(defroutes app-routes\r\n  \"Defined routes of the application\"\r\n  (GET \"/\" [] home)               ;; home-page\r\n  (route/resources \"/\" )          ;; resources required \r\n  (route/not-found \"Not found\"))  ;; exception case\r\n  \r\n(def handler\r\n  \"Handler chain invoked on a request by the server\"\r\n  (-> app-routes\r\n      wrap-params))\r\n~~~\r\n\r\nThe handler is passed to the [Jetty](http://www.eclipse.org/jetty/) web-server at start-up time (the details are found in the [`project.clj`](https://github.com/glgit/tutorial/blob/master/ex1/project.clj) configuration file under `:ring`). The example is available [here](https://github.com/glgit/tutorial/tree/master/ex1).\r\n\r\n###  A First Interface getAccounts\r\nFirst, we define example data.  For this purpose, we simply declare  an immutable map of accounts, where each account is described by a map too. Here, just a single account with three credit and debit bookings.  \r\n\r\n~~~~Clojure\r\n(def account-test-data\r\n    {:101 {:account-id 101 :currency \"CHF\" \r\n     :bookings[ {:amount 100  :value-date \"2014-01-02\" :ccy \"CHF\" :xref \"A1\"}\r\n                {:amount -100 :value-date \"2014-01-02\" :ccy \"CHF\" :xref \"A2\"}\r\n                {:amount 100  :value-date \"2014-01-02\" :ccy \"CHF\" :xref \"A3\"}]})\r\n~~~~\r\n\r\nFor updating the data, we assign the defined map to an *atom* , i.e. a named reference holding our  immutable value and  providing functions to swap one value with another one.  \r\n\r\n~~~~Clojure\r\n(def accounts-data (atom account-test-data))\r\n~~~~\r\n\r\n\r\nSecond, we need a handler for our interface method. The library [Liberator](http://clojure-liberator.github.io/liberator/) implements the REST protocol as per RFC.  Here, we use this library and add the necessary logic for our particular handler. \r\n\r\n~~~~Clojure\r\n(defresource accounts-r [id]\r\n\t:available-media-types [\"application/json\"]\r\n\t:allowed-methods [:get]\r\n\t:exists? (fn [_]\r\n\t\t\t\t (if-let [acc-j  (get-in @account [(keyword id)])]\r\n\t\t\t\t\t[true  {:account  acc-j}]\r\n\t\t\t\t\t[false {:message (format \"Account %s not found\" id)}]))\r\n\t:handle-ok (fn [{acc-j :account}](j/write-str acc-j)))\r\n~~~~\r\nThis resource definition includes a check whether the requested account exists or not and a handler that returns the retrieved account. \r\n\r\nNow, we can run on the command line the server and use `curl` to invoke the service (as soon as the hello world we-page is showing up). Alternatively, we can also type the URL into the browser.\r\n \r\n~~~~\r\n$ curl -i http://localhost:8000/accounts/101  returns the account object\r\n$ curl -i http://localhost:8000/accounts/1012 returns a 404\r\n~~~~\r\n\r\nAt this point, we have a working RESTful interface.  But, the developer of the next interface has to understand the Liberator library. Furthermore, the developer might make different design choices and hence each interface implementation might be somewhat different. Could we not standardize this resource definition and provide it as a library?\r\n\r\n\r\n###  A Standardized Re-usable Controller\r\nFor building a reusable resource definition, I have to understand first how the MVC design pattern relates to the above code. Second, where to use protocols to decouple the controller.\r\n\r\nThe MVC pattern resource *model*,  *view* and *controller* correspond   in above code to the ``atom`` with the functions on this atom, the reader/writer for JSON , and the ``defresource`` form that defines the controller.    \r\n\r\nA GET controller has always the same structure, so that I rewrite the above example as the following Clojure macro (assuming that this is a good enough one).  \r\n\r\n~~~Clojure\r\n(defmacro my-r-macro\r\n  [r-name r-id & {:keys [lookup-fn]}]\r\n  `(defresource ~r-name [~r-id]\r\n     :allowed-methods [:get ]\r\n     :known-content-type? #(check-content-type % [\"application/json\"])\r\n     :exists?\r\n         (fn [_#]\r\n            (if-let [res# (~lookup-fn (keyword ~r-id))]\r\n                true\r\n                [false {:message (format \"~r-name %s not found\" ~r-id)}]))\r\n     :handle-ok (fn [_#] (j/write-str (~lookup-fn (keyword ~r-id))))))\r\n\r\n~~~\r\nWith this macro, the actual controller definition is expressed in terms of the macro, that is:      \r\n      \r\n~~~Clojure\r\n(my-r-macro accounts-r id\r\n            :lookup-fn lookup-accounts)\r\n~~~\r\n\r\nThis simple macro, requires that we declare the functions used to access the model. This results in unnecessary boiler-plate code. More importantly, the requirements on these functions are not clearly specified.  \r\n \r\nTo address these shortcomings, I introduce a *protocol* defining the signature to access the resource models. \r\n\r\n~~~\tClojure\r\n    (defprotocol` RM-Accessor\r\n\t  (get-item [this id])\r\n\t  (duplicate-item? [this id item])\r\n\t  (valid-item? [this id item])\r\n\t  (add-item [this id item]))\r\n~~~\r\nThis protocol supports also the update of a resource using a `POST`. Before adding an item, you can determine whether the item is a duplicate and whether it is valid. \r\n\r\nI rewrite next the controller macro using the protocol just defined. In above macro example, we replace the `~lookup-fn` by the protocol function `get-item`. The latter requires as a first argument a type instance implementing the protocol, wich I will call  `r-m` - an input argument of the macro.\r\n  \r\n~~~Clojure\r\n(defmacro defresource-macro  [r-name r-id r-m & {:keys [malformed-fn]}]\r\n\t  `(defresource ~r-name [~r-id]\r\n\t     :available-media-types [\"application/json\"]\r\n\t     :allowed-methods [:get :post]\r\n\t     :known-content-type? \r\n\t        #(check-content-type % [\"application/json\"])\r\n\t     :malformed?\r\n\t       (fn [{{method# :request-method} :request :as ctx#}]\r\n\t         (if (= :post method#)\r\n\t           (try\r\n\t            (if-let [body# (body-as-string ctx#)]\r\n\t              (let [record# (j/read-str body# :key-fn keyword)]\r\n\t                 (if (~malformed-fn record#)\r\n\t                   [true  {:message \"booking incomplete.\"}]\r\n\t                   (if (not (valid-item? ~r-m ~r-id record#))\r\n\t                     [true  {:message \"invalid entry\" }]\r\n\t                     [false {:record record#}])))\r\n\t              [true {:message \"No body\"}])\r\n\t          (catch Exception e#\r\n                      [true {:message (format \"exception: %s\" (.getMessage e#))}]))))\r\n    :exists?\r\n        (fn [_#]\r\n           (if-let [res# (get-item ~r-m ~r-id)]\r\n              [true res#]\r\n              [false {:message (format \"%s %s not found...\" (get-name ~r-m) ~r-id)}]))\r\n    :can-post-to-missing?\r\n         (fn [_#] [false {:message (format \"%s %s not found!\" (get-name ~r-m) ~r-id)}])\r\n    :post!\r\n         (fn [{record# :record}]\r\n              (if (duplicate-item? ~r-m ~r-id record#)\r\n                [false {:message (format \"account booking %s already exists\" ~r-id)}]\r\n                [true  {:result (add-item ~r-m ~r-id record#)}]))            \r\n    :location #(build-entry-url (get % :request) )\r\n    :handle-ok (fn [_#] (j/write-str (get-item ~r-m ~r-id)))))\r\n\r\n~~~\r\nYou might want to compare the rewrite of the functions that define `:exists?` and `:handle-ok`.  The additional functions are necessary for the POST method  main methods are:\r\n\r\n- `:malformed?` checks whether the request itself is valid. I my implementation, I distinguish between the protocol- and model-specific validation. The former and the latter are carried out by the functions `~malformed-fn` and the protocol function `validate-item`. \r\n\r\n- `:post!` updates the accounts `atom` unless the booking item is a duplicate. \r\n\r\n\r\nBefore I can create an interface using the re-written macro, I have to implement the protocol. Clojure provides `deftype` and `defrecord` for implementing types in the implementation and application domain, respectively.\r\n\r\nThe kind of resource model is defined by a type. As an example, I define `DependentResource`, which is suitable to handle bookings given an account identifier. \r\n \r\n~~~~Clojure\r\n(deftype DependentResourceModel [rm-name data schema validation-fn dr-key xref-key]\r\n   RM-Accessor\r\n   (get-item [this id]\r\n      (get-in @data [(keyword id) dr-key]))\r\n   (duplicate-item? [this id item]\r\n      (if (empty? (xref-key item))\r\n        false\r\n       (let [journal (get-in @data [(keyword id) dr-key])\r\n             item-keys (vec\r\n                        (clojure.set/difference\r\n                           (set (keys item)) (set (list xref-key))))]\r\n         (clojure.set/subset?\r\n            (clojure.set/project (set (list item)) item-keys )\r\n            (clojure.set/project (set journal) item-keys)))))\r\n   (valid-item? [this id item]\r\n      (let [obj (get-in @data [(keyword id)])\r\n            v1 (valid-schema? schema item)\r\n            v2 (validation-fn obj item)]\r\n        (and (first v1)(first v2))))\r\n   (add-item [this id item]\r\n      (let [j-item (conj {:time-stamp (l/format-local-time\r\n                                           (l/local-now) :date-time)} item)\r\n            items (get-in @data [(keyword id) dr-key])]\r\n         (swap! data assoc-in [(keyword id) dr-key]\r\n                              (vec (conj items j-item ))))))\r\n~~~~\r\n\r\nThis type implements \r\n\r\n- `get-item`to retrieve the account bookings (as per parameter `dr-key`) given the account identifier `id`; and\r\n\r\n- `add-item`to add an account booking `item` to a particular account `id`. \r\n\r\nThe function  `valid-item?` checks `valid-schema?` and `validation-fn`. The latter checks in our example that the currency of the booking item corresponds to the account currency.  The former checks that a booking item complies with the data shape defined for it.   \r\n\r\n\r\nFor defining data shapes and validation them, I use the [schema](https://github.com/Prismatic/schema) library.   \r\n\r\n~~~Clojure\r\n\t(s/defschema account-booking-s\r\n\t   {:value-date (s/pred value-date? 'value-date?)\r\n\t    :amount s/Num                                 \r\n\t    :ccy currency-code-s                        \r\n\t    (s/optional-key :xref)s/Str\r\n\t    (s/optional-key :ts) s/Str})\r\n~~~\r\nNoteworthy is the definition of a predicate `value-date?` that checks that the value is a string in the format `\"YYYY-MM-DD\"` that represents a valid date. Furthermore, I apply first validations only where necessary - here the `POST`request body. Second, the schemata are not imposing type constraints on the implementations. This makes it possible to aim for generic implementations, but constrain their inputs as necessary from a business perspective.   \r\n\r\nAt this point, we can define our RESTful interface by simply declaring a suitable resource type instance that takes as arguments\r\n\r\n - an atom `accounts-data` and schema `accounts-booking-s\r\n - a `booking-validation-fn?`; and \r\n - the keywords used by the type-specific protocol implementation.\r\n \r\n\r\n~~~Clojure\r\n\r\n(def accounts-bookings-r-m\r\n  (DependentResourceModel.  \"account-bookings\" \r\n                            accounts-data account-booking-s\r\n                            booking-validation-fn? \r\n                            :bookings :xref))\r\n\r\n(defresource-macro accounts-bookings-r id\r\n            accounts-bookings-r-m\r\n            :malformed-fn malformed-request?)         \r\n~~~            \r\n\r\nThis definition is sufficient to implement RESTful interfaces for dependent resources using JSON as media type. Under the hood of this macro, we could replace the REST library or extend the macro to support multiple media types as well as to provide end-points using additional transport protools, such SOAP/HTTPs.\r\n  \r\n\r\nA solution architect designing an application need only to follow *\"Don't Repeat Yourself\" (DRY)* to obtain the here outlined solution.  For institutionalizing such a solution across a domain or enterprise, one could adopt a community approach or implement integration libraries centrally. \r\n\r\n\r\n[Attribution-NonCommercial-NoDerivatives 4.0 International License](https://i.creativecommons.org/l/by-nc-nd/4.0/80x15.png\")\r\n\r\n<img alt=\"Creative Commons License\" style=\"border-width:0\" src=\"https://i.creativecommons.org/l/by-nc-nd/4.0/80x15.png\" /></a><br />\r\nThis work is licensed under a <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-nd/4.0/\">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}