<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>A Pragmatic Architect by glgit</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">A Pragmatic Architect</h1>
      <h2 class="project-tagline">Architecture Posts</h2>
      <a href="https://github.com/glgit/pragmatic-architect" class="btn">View on GitHub</a>
      <a href="https://github.com/glgit/pragmatic-architect/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/glgit/pragmatic-architect/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="restful-interfaces-in-the-small-and-in-the-large" class="anchor" href="#restful-interfaces-in-the-small-and-in-the-large" aria-hidden="true"><span class="octicon octicon-link"></span></a>RESTful Interfaces in the Small and in the Large</h1>

<p>June, 17th 2015 </p>

<p>This post outlines an architecture strategy to design-in-the-small standardized components - just following the <em>Don't Repeat Yourself (DRY)</em> principle - and to scale them for whole application landscapes. </p>

<h2>
<a id="introduction" class="anchor" href="#introduction" aria-hidden="true"><span class="octicon octicon-link"></span></a>Introduction</h2>

<h3>
<a id="problem" class="anchor" href="#problem" aria-hidden="true"><span class="octicon octicon-link"></span></a>Problem</h3>

<p>At the beginning, we often implement a few interfaces. The number of interfaces grows then over time significantly. Interface implementations are often representing a significant percentage of the code base and hence costs.  </p>

<p>What <strong>architectures strategies</strong> for implementing interfaces provide <em>economies of scale</em> and facilitate the transition from the <em>programming-in-the-small</em> to the <em>programming-in-the-large</em>? </p>

<h3>
<a id="solution" class="anchor" href="#solution" aria-hidden="true"><span class="octicon octicon-link"></span></a>Solution</h3>

<p>The solution, which I present here, is based on the following principles</p>

<ul>
<li><p>Adopt early on <em>design patterns</em> to standardize the design;</p></li>
<li><p>Use the programming-language's <em>interface</em> to decouple the pattern elements; and</p></li>
<li><p>Generalize pattern elements to re-use them across the board. </p></li>
</ul>

<p>This is nothing new per se. But, the interesting twist is how to start programming- in-the-small and evolve the design to one that fits for programming-in-the-large. This requirement rules out strategies requiring a large initial investment.</p>

<p>As a case study, I show how to apply these principles to the  implementation of RESTful interfaces in the programming language Clojure. Clojure offers offers an interface notion, called <em>protocols</em>, and a <em>macro</em> mechanism that facilitates the generalization and re-use. As a design pattern, we use the  <em>Model-View-Controller (MVC)</em> design pattern []. For a brief summary of concepts, see Appendix. </p>

<h2>
<a id="the-solution" class="anchor" href="#the-solution" aria-hidden="true"><span class="octicon octicon-link"></span></a>The Solution</h2>

<p>Here, I use a simplified example for explanatory purposes. In particular, the functional scope is limited and data storage, security features and so on are omitted. The evolutionary design is outlined by a series of mini-tutorials for this example, which are available on <a href="https://github.com/glgit/tutorial/">here</a>. </p>

<p>An Interface Component provides in our case just</p>

<ul>
<li><p>A set of RESTful interfaces with  their <em>resources</em> and <em>methods</em>.  For instance, a resource currency <code>account</code> providing a <code>GET</code> method that accepts an account identifier and returns , if the caller is authorized,  the account data in JSON. </p></li>
<li><p>A mocked data set that the RESTful interfaces are delivering </p></li>
</ul>

<h2>
<a id="implementing-a-simple-interface" class="anchor" href="#implementing-a-simple-interface" aria-hidden="true"><span class="octicon octicon-link"></span></a>Implementing a simple interface</h2>

<h3>
<a id="hello-world-example" class="anchor" href="#hello-world-example" aria-hidden="true"><span class="octicon octicon-link"></span></a>Hello World Example</h3>

<p>In Clojure, the library  <a href="https://github.com/ring-clojure/ring">ring</a> and <a href="https://github.com/weavejester/compojure">compojure</a>      enable to define interfaces and <em>end-points</em> in terms of <em>routes</em> and their run-time context.  </p>

<p>As an example, I use these libraries to implement an interface that delivers a static HTML page. This is our "hello world" example to get started.</p>

<div class="highlight highlight-Clojure"><pre>(<span class="pl-k">defn</span> <span class="pl-e">home</span>
  <span class="pl-s"><span class="pl-pds">"</span>Function returning a static html page<span class="pl-pds">"</span></span>
  [req]
  (<span class="pl-en">render</span> (<span class="pl-en">io/resource</span> <span class="pl-s"><span class="pl-pds">"</span>index.html<span class="pl-pds">"</span></span>) req))

(<span class="pl-k">defroutes</span> app-routes
  <span class="pl-s"><span class="pl-pds">"</span>Defined routes of the application<span class="pl-pds">"</span></span>
  (<span class="pl-en">GET</span> <span class="pl-s"><span class="pl-pds">"</span>/<span class="pl-pds">"</span></span> [] home)               <span class="pl-c">;; home-page</span>
  (<span class="pl-en">route/resources</span> <span class="pl-s"><span class="pl-pds">"</span>/<span class="pl-pds">"</span></span> )          <span class="pl-c">;; resources required </span>
  (<span class="pl-en">route/not-found</span> <span class="pl-s"><span class="pl-pds">"</span>Not found<span class="pl-pds">"</span></span>))  <span class="pl-c">;; exception case</span>

(<span class="pl-k">def</span> <span class="pl-e">handler</span>
  <span class="pl-s"><span class="pl-pds">"</span>Handler chain invoked on a request by the server<span class="pl-pds">"</span></span>
  (<span class="pl-en">-&gt;</span> app-routes
      wrap-params))</pre></div>

<p>The handler is passed to the <a href="http://www.eclipse.org/jetty/">Jetty</a> web-server at start-up time (the details are found in the <a href="https://github.com/glgit/tutorial/blob/master/ex1/project.clj"><code>project.clj</code></a> configuration file under <code>:ring</code>). The example is available <a href="https://github.com/glgit/tutorial/tree/master/ex1">here</a>.</p>

<h3>
<a id="a-first-interface-getaccounts" class="anchor" href="#a-first-interface-getaccounts" aria-hidden="true"><span class="octicon octicon-link"></span></a>A First Interface getAccounts</h3>

<p>First, we define example data.  For this purpose, we simply declare  an immutable map of accounts, where each account is described by a map too. Here, just a single account with three credit and debit bookings.  </p>

<div class="highlight highlight-Clojure"><pre>(<span class="pl-k">def</span> <span class="pl-e">account-test-data</span>
    {<span class="pl-c1">:101</span> {<span class="pl-c1">:account-id</span> <span class="pl-c1">101</span> <span class="pl-c1">:currency</span> <span class="pl-s"><span class="pl-pds">"</span>CHF<span class="pl-pds">"</span></span> 
     :bookings[ {<span class="pl-c1">:amount</span> <span class="pl-c1">100</span>  <span class="pl-c1">:value-date</span> <span class="pl-s"><span class="pl-pds">"</span>2014-01-02<span class="pl-pds">"</span></span> <span class="pl-c1">:ccy</span> <span class="pl-s"><span class="pl-pds">"</span>CHF<span class="pl-pds">"</span></span> <span class="pl-c1">:xref</span> <span class="pl-s"><span class="pl-pds">"</span>A1<span class="pl-pds">"</span></span>}
                {<span class="pl-c1">:amount</span> <span class="pl-c1">-100</span> <span class="pl-c1">:value-date</span> <span class="pl-s"><span class="pl-pds">"</span>2014-01-02<span class="pl-pds">"</span></span> <span class="pl-c1">:ccy</span> <span class="pl-s"><span class="pl-pds">"</span>CHF<span class="pl-pds">"</span></span> <span class="pl-c1">:xref</span> <span class="pl-s"><span class="pl-pds">"</span>A2<span class="pl-pds">"</span></span>}
                {<span class="pl-c1">:amount</span> <span class="pl-c1">100</span>  <span class="pl-c1">:value-date</span> <span class="pl-s"><span class="pl-pds">"</span>2014-01-02<span class="pl-pds">"</span></span> <span class="pl-c1">:ccy</span> <span class="pl-s"><span class="pl-pds">"</span>CHF<span class="pl-pds">"</span></span> <span class="pl-c1">:xref</span> <span class="pl-s"><span class="pl-pds">"</span>A3<span class="pl-pds">"</span></span>}]})</pre></div>

<p>For updating the data, we assign the defined map to an <em>atom</em> , i.e. a named reference holding our  immutable value and  providing functions to swap one value with another one.  </p>

<div class="highlight highlight-Clojure"><pre>(<span class="pl-k">def</span> <span class="pl-e">accounts-data</span> (<span class="pl-en">atom</span> account-test-data))</pre></div>

<p>Second, we need a handler for our interface method. The library <a href="http://clojure-liberator.github.io/liberator/">Liberator</a> implements the REST protocol as per RFC.  Here, we use this library and add the necessary logic for our particular handler. </p>

<div class="highlight highlight-Clojure"><pre>(<span class="pl-k">defresource</span> accounts-r [id]
    <span class="pl-c1">:available-media-types</span> [<span class="pl-s"><span class="pl-pds">"</span>application/json<span class="pl-pds">"</span></span>]
    <span class="pl-c1">:allowed-methods</span> [<span class="pl-c1">:get</span>]
    <span class="pl-c1">:exists?</span> (<span class="pl-k">fn</span> [_]
                 (<span class="pl-k">if-let</span> [acc-j  (<span class="pl-en">get-in</span> @account [(<span class="pl-en">keyword</span> id)])]
                    [<span class="pl-c1">true</span>  {<span class="pl-c1">:account</span>  acc-j}]
                    [<span class="pl-c1">false</span> {<span class="pl-c1">:message</span> (<span class="pl-en">format</span> <span class="pl-s"><span class="pl-pds">"</span>Account %s not found<span class="pl-pds">"</span></span> id)}]))
    <span class="pl-c1">:handle-ok</span> (<span class="pl-k">fn</span> [{acc-j <span class="pl-c1">:account</span>}](<span class="pl-en">j/write-str</span> acc-j)))</pre></div>

<p>This resource definition includes a check whether the requested account exists or not and a handler that returns the retrieved account. </p>

<p>Now, we can run on the command line the server and use <code>curl</code> to invoke the service (as soon as the hello world we-page is showing up). Alternatively, we can also type the URL into the browser.</p>

<pre><code>$ curl -i http://localhost:8000/accounts/101  returns the account object
$ curl -i http://localhost:8000/accounts/1012 returns a 404
</code></pre>

<p>At this point, we have a working RESTful interface.  But, the developer of the next interface has to understand the Liberator library. Furthermore, the developer might make different design choices and hence each interface implementation might be somewhat different. Could we not standardize this resource definition and provide it as a library?</p>

<h3>
<a id="a-standardized-re-usable-controller" class="anchor" href="#a-standardized-re-usable-controller" aria-hidden="true"><span class="octicon octicon-link"></span></a>A Standardized Re-usable Controller</h3>

<p>For building a reusable resource definition, I have to understand first how the MVC design pattern relates to the above code. Second, where to use protocols to decouple the controller.</p>

<p>The MVC pattern resource <em>model</em>,  <em>view</em> and <em>controller</em> correspond   in above code to the <code>atom</code> with the functions on this atom, the reader/writer for JSON , and the <code>defresource</code> form that defines the controller.    </p>

<p>A GET controller has always the same structure, so that I rewrite the above example as the following Clojure macro (assuming that this is a good enough one).  </p>

<div class="highlight highlight-Clojure"><pre>(<span class="pl-k">defmacro</span> <span class="pl-e">my-r-macro</span>
  [r-name r-id &amp; {<span class="pl-c1">:keys</span> [lookup-fn]}]
  `(<span class="pl-k">defresource</span> ~r-name [~r-id]
     <span class="pl-c1">:allowed-methods</span> [<span class="pl-c1">:get</span> ]
     <span class="pl-c1">:known-content-type?</span> #(<span class="pl-en">check-content-type</span> % [<span class="pl-s"><span class="pl-pds">"</span>application/json<span class="pl-pds">"</span></span>])
     <span class="pl-c1">:exists?</span>
         (<span class="pl-k">fn</span> [_#]
            (<span class="pl-k">if-let</span> [res# (<span class="pl-en">~lookup-fn</span> (<span class="pl-en">keyword</span> ~r-id))]
                <span class="pl-c1">true</span>
                [<span class="pl-c1">false</span> {<span class="pl-c1">:message</span> (<span class="pl-en">format</span> <span class="pl-s"><span class="pl-pds">"</span>~r-name %s not found<span class="pl-pds">"</span></span> ~r-id)}]))
     <span class="pl-c1">:handle-ok</span> (<span class="pl-k">fn</span> [_#] (<span class="pl-en">j/write-str</span> (<span class="pl-en">~lookup-fn</span> (<span class="pl-en">keyword</span> ~r-id))))))
</pre></div>

<p>With this macro, the actual controller definition is expressed in terms of the macro, that is:      </p>

<div class="highlight highlight-Clojure"><pre>(<span class="pl-en">my-r-macro</span> accounts-r id
            <span class="pl-c1">:lookup-fn</span> lookup-accounts)</pre></div>

<p>This simple macro, requires that we declare the functions used to access the model. This results in unnecessary boiler-plate code. More importantly, the requirements on these functions are not clearly specified.  </p>

<p>To address these shortcomings, I introduce a <em>protocol</em> defining the signature to access the resource models. </p>

<div class="highlight highlight-Clojure"><pre>    (<span class="pl-en">defprotocol`</span> RM-Accessor
      (<span class="pl-en">get-item</span> [this id])
      (<span class="pl-en">duplicate-item?</span> [this id item])
      (<span class="pl-en">valid-item?</span> [this id item])
      (<span class="pl-en">add-item</span> [this id item]))</pre></div>

<p>This protocol supports also the update of a resource using a <code>POST</code>. Before adding an item, you can determine whether the item is a duplicate and whether it is valid. </p>

<p>I rewrite next the controller macro using the protocol just defined. In above macro example, we replace the <code>~lookup-fn</code> by the protocol function <code>get-item</code>. The latter requires as a first argument a type instance implementing the protocol, wich I will call  <code>r-m</code> - an input argument of the macro.</p>

<div class="highlight highlight-Clojure"><pre>(<span class="pl-k">defmacro</span> <span class="pl-e">defresource-macro</span>  [r-name r-id r-m &amp; {<span class="pl-c1">:keys</span> [malformed-fn]}]
      `(<span class="pl-k">defresource</span> ~r-name [~r-id]
         <span class="pl-c1">:available-media-types</span> [<span class="pl-s"><span class="pl-pds">"</span>application/json<span class="pl-pds">"</span></span>]
         <span class="pl-c1">:allowed-methods</span> [<span class="pl-c1">:get</span> <span class="pl-c1">:post</span>]
         <span class="pl-c1">:known-content-type?</span> 
            #(<span class="pl-en">check-content-type</span> % [<span class="pl-s"><span class="pl-pds">"</span>application/json<span class="pl-pds">"</span></span>])
         <span class="pl-c1">:malformed?</span>
           (<span class="pl-k">fn</span> [{{method# <span class="pl-c1">:request-method</span>} <span class="pl-c1">:request</span> <span class="pl-c1">:as</span> ctx#}]
             (<span class="pl-k">if</span> (<span class="pl-en">=</span> <span class="pl-c1">:post</span> method#)
               (<span class="pl-k">try</span>
                (<span class="pl-k">if-let</span> [body# (<span class="pl-en">body-as-string</span> ctx#)]
                  (<span class="pl-k">let</span> [record# (<span class="pl-en">j/read-str</span> body# <span class="pl-c1">:key-fn</span> keyword)]
                     (<span class="pl-k">if</span> (<span class="pl-en">~malformed-fn</span> record#)
                       [<span class="pl-c1">true</span>  {<span class="pl-c1">:message</span> <span class="pl-s"><span class="pl-pds">"</span>booking incomplete.<span class="pl-pds">"</span></span>}]
                       (<span class="pl-k">if</span> (<span class="pl-en">not</span> (<span class="pl-en">valid-item?</span> ~r-m ~r-id record#))
                         [<span class="pl-c1">true</span>  {<span class="pl-c1">:message</span> <span class="pl-s"><span class="pl-pds">"</span>invalid entry<span class="pl-pds">"</span></span> }]
                         [<span class="pl-c1">false</span> {<span class="pl-c1">:record</span> record#}])))
                  [<span class="pl-c1">true</span> {<span class="pl-c1">:message</span> <span class="pl-s"><span class="pl-pds">"</span>No body<span class="pl-pds">"</span></span>}])
              (<span class="pl-k">catch</span> Exception e#
                      [<span class="pl-c1">true</span> {<span class="pl-c1">:message</span> (<span class="pl-en">format</span> <span class="pl-s"><span class="pl-pds">"</span>exception: %s<span class="pl-pds">"</span></span> (<span class="pl-en">.getMessage</span> e#))}]))))
    <span class="pl-c1">:exists?</span>
        (<span class="pl-k">fn</span> [_#]
           (<span class="pl-k">if-let</span> [res# (<span class="pl-en">get-item</span> ~r-m ~r-id)]
              [<span class="pl-c1">true</span> res#]
              [<span class="pl-c1">false</span> {<span class="pl-c1">:message</span> (<span class="pl-en">format</span> <span class="pl-s"><span class="pl-pds">"</span>%s %s not found...<span class="pl-pds">"</span></span> (<span class="pl-en">get-name</span> ~r-m) ~r-id)}]))
    <span class="pl-c1">:can-post-to-missing?</span>
         (<span class="pl-k">fn</span> [_#] [<span class="pl-c1">false</span> {<span class="pl-c1">:message</span> (<span class="pl-en">format</span> <span class="pl-s"><span class="pl-pds">"</span>%s %s not found!<span class="pl-pds">"</span></span> (<span class="pl-en">get-name</span> ~r-m) ~r-id)}])
    <span class="pl-c1">:post!</span>
         (<span class="pl-k">fn</span> [{record# <span class="pl-c1">:record</span>}]
              (<span class="pl-k">if</span> (<span class="pl-en">duplicate-item?</span> ~r-m ~r-id record#)
                [<span class="pl-c1">false</span> {<span class="pl-c1">:message</span> (<span class="pl-en">format</span> <span class="pl-s"><span class="pl-pds">"</span>account booking %s already exists<span class="pl-pds">"</span></span> ~r-id)}]
                [<span class="pl-c1">true</span>  {<span class="pl-c1">:result</span> (<span class="pl-en">add-item</span> ~r-m ~r-id record#)}]))            
    <span class="pl-c1">:location</span> #(<span class="pl-en">build-entry-url</span> (<span class="pl-en">get</span> % <span class="pl-c1">:request</span>) )
    <span class="pl-c1">:handle-ok</span> (<span class="pl-k">fn</span> [_#] (<span class="pl-en">j/write-str</span> (<span class="pl-en">get-item</span> ~r-m ~r-id)))))
</pre></div>

<p>You might want to compare the rewrite of the functions that define <code>:exists?</code> and <code>:handle-ok</code>.  The additional functions are necessary for the POST method  main methods are:</p>

<ul>
<li><p><code>:malformed?</code> checks whether the request itself is valid. I my implementation, I distinguish between the protocol- and model-specific validation. The former and the latter are carried out by the functions <code>~malformed-fn</code> and the protocol function <code>validate-item</code>. </p></li>
<li><p><code>:post!</code> updates the accounts <code>atom</code> unless the booking item is a duplicate. </p></li>
</ul>

<p>Before I can create an interface using the re-written macro, I have to implement the protocol. Clojure provides <code>deftype</code> and <code>defrecord</code> for implementing types in the implementation and application domain, respectively.</p>

<p>The kind of resource model is defined by a type. As an example, I define <code>DependentResource</code>, which is suitable to handle bookings given an account identifier. </p>

<div class="highlight highlight-Clojure"><pre>(<span class="pl-k">deftype</span> DependentResourceModel [rm-name data schema validation-fn dr-key xref-key]
   RM-Accessor
   (<span class="pl-en">get-item</span> [this id]
      (<span class="pl-en">get-in</span> @data [(<span class="pl-en">keyword</span> id) dr-key]))
   (<span class="pl-en">duplicate-item?</span> [this id item]
      (<span class="pl-k">if</span> (<span class="pl-en">empty?</span> (<span class="pl-en">xref-key</span> item))
        <span class="pl-c1">false</span>
       (<span class="pl-k">let</span> [journal (<span class="pl-en">get-in</span> @data [(<span class="pl-en">keyword</span> id) dr-key])
             item-keys (<span class="pl-en">vec</span>
                        (<span class="pl-en">clojure.set/difference</span>
                           (<span class="pl-en">set</span> (<span class="pl-en">keys</span> item)) (<span class="pl-en">set</span> (<span class="pl-en">list</span> xref-key))))]
         (<span class="pl-en">clojure.set/subset?</span>
            (<span class="pl-en">clojure.set/project</span> (<span class="pl-en">set</span> (<span class="pl-en">list</span> item)) item-keys )
            (<span class="pl-en">clojure.set/project</span> (<span class="pl-en">set</span> journal) item-keys)))))
   (<span class="pl-en">valid-item?</span> [this id item]
      (<span class="pl-k">let</span> [obj (<span class="pl-en">get-in</span> @data [(<span class="pl-en">keyword</span> id)])
            v1 (<span class="pl-en">valid-schema?</span> schema item)
            v2 (<span class="pl-en">validation-fn</span> obj item)]
        (<span class="pl-en">and</span> (<span class="pl-en">first</span> v1)(<span class="pl-en">first</span> v2))))
   (<span class="pl-en">add-item</span> [this id item]
      (<span class="pl-k">let</span> [j-item (<span class="pl-en">conj</span> {<span class="pl-c1">:time-stamp</span> (<span class="pl-en">l/format-local-time</span>
                                           (<span class="pl-en">l/local-now</span>) <span class="pl-c1">:date-time</span>)} item)
            items (<span class="pl-en">get-in</span> @data [(<span class="pl-en">keyword</span> id) dr-key])]
         (<span class="pl-en">swap!</span> data assoc-in [(<span class="pl-en">keyword</span> id) dr-key]
                              (<span class="pl-en">vec</span> (<span class="pl-en">conj</span> items j-item ))))))</pre></div>

<p>This type implements </p>

<ul>
<li><p><code>get-item</code>to retrieve the account bookings (as per parameter <code>dr-key</code>) given the account identifier <code>id</code>; and</p></li>
<li><p><code>add-item</code>to add an account booking <code>item</code> to a particular account <code>id</code>. </p></li>
</ul>

<p>The function  <code>valid-item?</code> checks <code>valid-schema?</code> and <code>validation-fn</code>. The latter checks in our example that the currency of the booking item corresponds to the account currency.  The former checks that a booking item complies with the data shape defined for it.   </p>

<p>For defining data shapes and validation them, I use the <a href="https://github.com/Prismatic/schema">schema</a> library.   </p>

<div class="highlight highlight-Clojure"><pre>    (<span class="pl-en">s/defschema</span> account-booking-s
       {<span class="pl-c1">:value-date</span> (<span class="pl-en">s/pred</span> value-date? 'value-date?)
        <span class="pl-c1">:amount</span> s/Num                                 
        <span class="pl-c1">:ccy</span> currency-code-s                        
        (<span class="pl-en">s/optional-key</span> <span class="pl-c1">:xref</span>)s/Str
        (<span class="pl-en">s/optional-key</span> <span class="pl-c1">:ts</span>) s/Str})</pre></div>

<p>Noteworthy is the definition of a predicate <code>value-date?</code> that checks that the value is a string in the format <code>"YYYY-MM-DD"</code> that represents a valid date. Furthermore, I apply first validations only where necessary - here the <code>POST</code>request body. Second, the schemata are not imposing type constraints on the implementations. This makes it possible to aim for generic implementations, but constrain their inputs as necessary from a business perspective.   </p>

<p>At this point, we can define our RESTful interface by simply declaring a suitable resource type instance that takes as arguments</p>

<ul>
<li>an atom <code>accounts-data</code> and schema `accounts-booking-s</li>
<li>a <code>booking-validation-fn?</code>; and </li>
<li>the keywords used by the type-specific protocol implementation.</li>
</ul>

<div class="highlight highlight-Clojure"><pre>
(<span class="pl-k">def</span> <span class="pl-e">accounts-bookings-r-m</span>
  (<span class="pl-en">DependentResourceModel.</span>  <span class="pl-s"><span class="pl-pds">"</span>account-bookings<span class="pl-pds">"</span></span> 
                            accounts-data account-booking-s
                            booking-validation-fn? 
                            <span class="pl-c1">:bookings</span> <span class="pl-c1">:xref</span>))

(<span class="pl-k">defresource-macro</span> accounts-bookings-r id
            accounts-bookings-r-m
            <span class="pl-c1">:malformed-fn</span> malformed-request?)         </pre></div>

<p>This definition is sufficient to implement RESTful interfaces for dependent resources using JSON as media type. Under the hood of this macro, we could replace the REST library or extend the macro to support multiple media types as well as to provide end-points using additional transport protools, such SOAP/HTTPs.</p>

<p>A solution architect designing an application need only to follow <em>"Don't Repeat Yourself" (DRY)</em> to obtain the here outlined solution.  For institutionalizing such a solution across a domain or enterprise, one could adopt a community approach or implement integration libraries centrally. </p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/glgit/pragmatic-architect">A Pragmatic Architect</a> is maintained by <a href="https://github.com/glgit">glgit</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>

